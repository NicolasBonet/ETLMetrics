<?xml version="1.0" encoding="ASCII"?>
<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:jEE="http://www.example.org/jEE" xmlns:kdm="http://www.eclipse.org/MoDisco/kdm/kdm">
  <jEE:JEE/>
  <jEE:JEE>
    <Ejbs name="BolsaDeEmpleoEJB">
      <bussinesMethods name="BolsaDeEmpleo" return="void" code="        aspirantes = new ArrayList( );&#xA;&#xA;"/>
      <bussinesMethods name="darAspirantes" return="ArrayList&lt;E>" code="        ArrayList copia = new ArrayList( aspirantes );&#xA;        return copia;&#xA;"/>
      <bussinesMethods name="ordenarPorNombre" return="void" code="        for( int i = aspirantes.size( ); i > 0; i-- )&#xA;        {&#xA;            for( int j = 0; j &lt; i - 1; j++ )&#xA;            {&#xA;                Aspirante a1 = ( Aspirante )aspirantes.get( j );&#xA;                Aspirante a2 = ( Aspirante )aspirantes.get( j + 1 );&#xA;&#xA;                // Si es necesario se deben intercambiar a1 y a2&#xA;                if( a1.compararPorNombre( a2 ) > 0 )&#xA;                {&#xA;                    aspirantes.set( j, a2 );&#xA;                    aspirantes.set( j + 1, a1 );&#xA;                }&#xA;            }&#xA;        }&#xA;        verificarInvariante( );&#xA;"/>
      <bussinesMethods name="ordenarPorEdad" return="void" code="        int inicial;&#xA;        // En cada iteraci&#xfffd;n se sabe que:&#xA;        // 1. Las posiciones antes de aspirantes[inicial] est&#xfffd;n ordenadas por edad&#xA;        // 2. No hay ning&#xfffd;n valor despu&#xfffd;s de aspirantes[inicial-1] que sea menor que aspirantes[inicial-1]&#xA;        // En cada iteraci&#xfffd;n se busca el menor entre aspirantes[inicial] y aspirantes[final] y se ubica en aspirantes[inicial]&#xA;&#xA;        for( inicial = 0; inicial &lt; aspirantes.size( ); inicial++ )&#xA;        {&#xA;            int posicionMenor = inicial;&#xA;            Aspirante aspiranteMenor = ( Aspirante )aspirantes.get( inicial );&#xA;&#xA;            // Buscar el Aspirante de menor [int, Edad, Seleccion] entre inicial y final&#xA;            for( int i = inicial + 1; i &lt; aspirantes.size( ); i++ )&#xA;            {&#xA;                Aspirante aspirantePosicion = ( Aspirante )aspirantes.get( i );&#xA;&#xA;                // El aspirante de la posicion actual es menor que el menor encontrado hasta el momento&#xA;                if( aspirantePosicion.compararPorEdad( aspiranteMenor ) &lt; 0 )&#xA;                {&#xA;                    aspiranteMenor = aspirantePosicion;&#xA;                    posicionMenor = i;&#xA;                }&#xA;            }&#xA;&#xA;            if( posicionMenor != inicial )&#xA;            {&#xA;                Aspirante temp = ( Aspirante )aspirantes.get( inicial );&#xA;                aspirantes.set( inicial, aspiranteMenor );&#xA;                aspirantes.set( posicionMenor, temp );&#xA;            }&#xA;&#xA;        }&#xA;        verificarInvariante( );&#xA;"/>
      <bussinesMethods name="ordenarPorProfesion" return="void" code="        for( int i = aspirantes.size( ); i > 0; i-- )&#xA;        {&#xA;            for( int j = 0; j &lt; i - 1; j++ )&#xA;            {&#xA;                Aspirante a1 = ( Aspirante )aspirantes.get( j );&#xA;                Aspirante a2 = ( Aspirante )aspirantes.get( j + 1 );&#xA;&#xA;                // Si es necesario se deben intercambiar a1 y a2&#xA;                if( a1.compararPorProfesion( a2 ) > 0 )&#xA;                {&#xA;                    aspirantes.set( j, a2 );&#xA;                    aspirantes.set( j + 1, a1 );&#xA;                }&#xA;            }&#xA;        }&#xA;        verificarInvariante( );&#xA;"/>
      <bussinesMethods name="ordenarPorAniosDeExperiencia" return="void" code="        int inicial;&#xA;&#xA;        // En cada paso se sabe que:&#xA;        // 1. Las posiciones antes de aspirantes[inicial] est&#xfffd;n ordenadas&#xA;        // En cada paso lo que se hace es encontrar en qu&#xfffd; posici&#xfffd;n entre aspirantes[0] y aspirantes[inicial] deber&#xfffd;a&#xA;        // estar el aspirante que en este momento se encuentra en aspirante[inicial]&#xA;&#xA;        for( inicial = 1; inicial &lt; aspirantes.size( ); inicial++ )&#xA;        {&#xA;            Aspirante insertado = ( Aspirante )aspirantes.get( inicial );&#xA;&#xA;            boolean termine = false;&#xA;            int i = inicial - 1;&#xA;&#xA;            while( !termine )&#xA;            {&#xA;                // Si encuentra un cilindraje mayor, entonces hay que intercambiarlos&#xA;                Aspirante aspirantePosicion = ( Aspirante )aspirantes.get( i );&#xA;&#xA;                if( aspirantePosicion.compararPorAniosExperiencia( insertado ) > 0 )&#xA;                {&#xA;                    aspirantes.set( i, insertado );&#xA;                    aspirantes.set( i + 1, aspirantePosicion );&#xA;                    i--;&#xA;                }&#xA;                // Si se encuentra un cilindraje igual o menor entonces ya se encontr&#xfffd; la posici&#xfffd;n&#xA;                else&#xA;                {&#xA;                    termine = true;&#xA;                }&#xA;&#xA;                // Si ya se lleg&#xfffd; al principio de la lista no hay nada m&#xfffd;s que hacer&#xA;                if( i &lt; 0 )&#xA;                {&#xA;                    termine = true;&#xA;                }&#xA;            }&#xA;        }&#xA;        verificarInvariante( );&#xA;"/>
    </Ejbs>
  </jEE:JEE>
  <jEE:Entity/>
  <jEE:Service/>
  <jEE:Method name="buscarAspirante" return="int"/>
  <kdm:Attribute/>
</xmi:XMI>
