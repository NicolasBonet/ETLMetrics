/*
 * generated by Xtext 2.9.1
 */
package uniandes.automat.sql.scoping

import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import uniandes.automat.sql.sql.ForeignKey
import uniandes.automat.sql.sql.Column
import org.eclipse.xtext.scoping.Scopes
import uniandes.automat.sql.sql.Table
import org.eclipse.emf.common.util.EList
//import uniandes.automat.sql.sql.TableFact
import java.util.ArrayList
import org.eclipse.emf.common.util.BasicEList

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
//class SqlScopeProvider extends AbstractSqlScopeProvider {
class SqlScopeProvider extends AbstractDeclarativeScopeProvider {
	
	
	
	override public IScope getScope(EObject context, EReference reference) {
		
		//System.out.println(context.class + "," + reference.name);
		
		if ((context instanceof ForeignKey) 
			&& reference.name.equals("foreignColumns")
		)
		{
			var Table refForeignTable = (context as ForeignKey).foreignTable;
			//System.out.println(refForeignTable.name);
			
			//ForeignKey -> Table -> Database
			for (var i = 0; i < context.eContainer.eContainer.eContents.size(); i++)
			{
				var Table iTable = (context.eContainer.eContainer.eContents.get(i) as Table);
				System.out.println(iTable.name);
				
				//Se econtro la tabla referenciada, devolver columnas 
				if (iTable.name.equals(refForeignTable.name))
				{
					var EList<EObject> facts = iTable.facts;
				 	var EList<Column> columns = new BasicEList<Column>();
				 	for(EObject f: facts){
				 		if(f instanceof Column){
				 			columns.add(f);
				 		}
				 	}
					return Scopes::scopeFor(columns);
				}
			}
			
			return null;
		}
		else
		{	
			return super.getScope(context, reference)
		}
	}
}
